import 'dart:typed_data';
import 'package:flutter/material.dart';
import 'package:geolocator/geolocator.dart';
import 'package:get/get.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:image_picker/image_picker.dart';
import 'package:intl/intl.dart';
import 'package:myapp/controller/chat_controller.dart';
import 'package:myapp/services/storage/fire_storage.dart';
import 'package:myapp/utils/image_select.dart';
import 'package:myapp/utils/upload_image_dialogue.dart';
import '../components/message_tile.dart';
import '../model/message.dart';
import '../utils/colors.dart';


class TimestampedMessageTile extends StatefulWidget {
  final String message;
  final String sender;
  final String time;
  final bool sentByMe;
  final String gifUrl;
  final bool isGif;

  const TimestampedMessageTile({
    Key? key,
    required this.message,
    required this.sender,
    required this.time,
    required this.sentByMe,
    required this.gifUrl,
    required this.isGif,
  }) : super(key: key);

  @override
  State<TimestampedMessageTile> createState() => _TimestampedMessageTileState();
}

class _TimestampedMessageTileState extends State<TimestampedMessageTile> {
  @override
  Widget build(BuildContext context) {
    final controller = Get.find<ChatController>();

    // Check if the sender is blocked
    if (controller.isUserBlocked(widget.sender)) {
      return Container(); // Don't display messages from blocked users
    }

    return Column(
      crossAxisAlignment:
          widget.sentByMe ? CrossAxisAlignment.end : CrossAxisAlignment.start,
      children: [
        GestureDetector(
          onTap: () {
            if (widget.isGif || _isImage(widget.gifUrl)) {
              // Display the image or GIF in a larger view when tapped
              Navigator.of(context).push(MaterialPageRoute(
                builder: (context) {
                  return ImageScreen(imageUrl: widget.gifUrl);
                },
              ));
            }
          },
          child: MessageTile(
            message: widget.message,
            sender: widget.sender,
            sentByMe: widget.sentByMe,
            gifUrl: widget.gifUrl,
            isGif: widget.isGif,
          ),
        ),
        // Padding for space below the timestamp
        Padding(
          padding: const EdgeInsets.only(left: 8, right: 8, top: 4, bottom: 12),
          child: Text(
            widget.time,
            style: const TextStyle(
              fontSize: 12,
              color: Colors.black45,
            ),
          ),
        ),
      ],
    );
  }

  bool _isImage(String url) {
    return url.toLowerCase().contains('.jpg') ||
        url.toLowerCase().contains('.jpeg') ||
        url.toLowerCase().contains('.png') ||
        url.toLowerCase().contains('.gif');
  }
}




class ImageScreen extends StatelessWidget {
  final String imageUrl;

  const ImageScreen({Key? key, required this.imageUrl}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        backgroundColor: Colors.black,
      ),
      body: Center(
        child: Hero(
          tag: imageUrl,
          child: GestureDetector(
            onTap: () {
              Navigator.pop(context);
            },
            child: Image.network(imageUrl),
          ),
        ),
      ),
    );
  }
}



class AutoGeneratedChatPage extends GetView<ChatController> {

  void _requestLocationPermission() async {
    LocationPermission permission = await Geolocator.requestPermission();

    if (permission == LocationPermission.denied) {
      // Handle the case where the user declined to grant location permission
    }
  }
    bool _isLocationAvailable() {
    // Your implementation to check if location is available
    // For example, you can use a location plugin or other relevant logic
    // Return true if location is available, false otherwise
    return true;
  }


 void _performManualCheckIn() async {
  _requestLocationPermission();
  bool isLocationAvailable = await _isLocationAvailable();

  if (isLocationAvailable) {
    Position position = await Geolocator.getCurrentPosition();
    // Handle the obtained position, for example, update it in your database

    // Manually check-in the user with the obtained position
    _manualCheckIn(position);
  } else {
    // Handle the case where location services are not available
  }
}void _manualCheckIn(Position position) {
  // Implement your logic for manual check-in here.
  // For example, update the user's location in the database.
  // You may also update the UI or perform any other actions.
  print('Manual check-in at ${position.latitude}, ${position.longitude}');
}

  int id = DateTime.now().millisecondsSinceEpoch;
  ScrollController? _scrollController; // Declare the ScrollController
  RxString recipientUserId = ''.obs;
  final Set<String> blockedUsers = {};


  void blockUser(String userId) {
    // Implement the logic to block the user
    // For example:
    blockedUsers.add(userId);
  }

  // Check if a user is blocked
  bool isUserBlocked(String userId) {
    return blockedUsers.contains(userId);
  }

  void _showInfoDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: Text(
            "Information",
            style: GoogleFonts.openSans(
              textStyle: TextStyle(
                  fontWeight: FontWeight.bold,
                  color: AppColors.primaryColor,
                  letterSpacing: .5),
            ),
          ),
          content: Text(
            "You can chat with everyone in your current location. Press Locate me button beside (i)",
            style: GoogleFonts.openSans(
              textStyle:
                  TextStyle(color: AppColors.primaryColor, letterSpacing: .5),
            ),
          ),
          actions: [
            TextButton(
              onPressed: () {
                Navigator.of(context).pop();
              },
              child: Text(
                "OK",
                style: GoogleFonts.openSans(
                  textStyle: TextStyle(
                      fontWeight: FontWeight.bold,
                      color: AppColors.primaryColor,
                      letterSpacing: .5),
                ),
              ),
            ),
          ],
        );
      },
    );
  }

  void _scrollToBottom() {
    _scrollController!.animateTo(
      _scrollController!.position.maxScrollExtent,
      duration: Duration(milliseconds: 300),
      curve: Curves.easeOut,
    );
  }
 @override
  Widget build(BuildContext context) {
    final controller = Get.find<ChatController>();
    _scrollController = ScrollController();

    return Scaffold(
      appBar: AppBar(
        centerTitle: true,
        elevation: 1,
        title: Obx(() => Text(
              "@ ${controller.streetName.value}",
              style: const TextStyle(color: Colors.white),
            )),
        backgroundColor: Colors.black,
        actions: [
          GestureDetector(
            onTap: () {
              _showInfoDialog(context);
            },
            child: Container(
              padding: const EdgeInsets.all(8),
              child: const Icon(Icons.info, color: Colors.white),
            ),
          ),
        ],
      ),
      body: SafeArea(
        child: Container(
          color: Colors.black,
          child: Container(
            decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.only(
                topRight: Radius.circular(40),
                topLeft: Radius.circular(40),
              ),
              border: Border.all(
                width: 3,
                color: Colors.white,
                style: BorderStyle.solid,
              ),
            ),
            child: Column(
              children: <Widget>[
                SizedBox(
                  height: 10,
                ),
                Padding(
                  padding: const EdgeInsets.all(8.0),
                  child: Row(
  mainAxisAlignment: MainAxisAlignment.end,
  children: [
    GestureDetector(
      onTap: () {
        controller.getUserLocation();
      },
      child: Container(
        padding: const EdgeInsets.all(8),
        child: const Icon(Icons.my_location_rounded, color: Colors.black),
      ),
    ),
    const SizedBox(width: 8),
    Text(
      "Locate Me",
      style: TextStyle(
        color: Colors.red, // Set the vibrant color you desire
        fontWeight: FontWeight.bold,
      ),
    ),
  ],
),

                ),
                Expanded(
                  child: Obx(() {
                    final reversedMessages =
                        controller.messagesList.reversed.toList();

                    return ListView.builder(
                      reverse: true,
                      controller: _scrollController,
                      physics: const BouncingScrollPhysics(),
                      padding: const EdgeInsets.only(bottom: 60),
                      itemCount: reversedMessages.length,
                      itemBuilder: (context, index) {
                        final message = reversedMessages[index];
                        final isSentByMe =
                            controller.firebaseAuth.currentUser?.uid ==
                                message.senderId;
                        return TimestampedMessageTile(
                          message: message.message,
                          sender: message.senderEmail,
                          time: _formatTimestamp(message.timestamp),
                          sentByMe: isSentByMe,
                          gifUrl: message.gifUrl,
                          isGif: message.isGif,
                        );
                      },
                    );
                  }),
                ),
                _buildMessageInput(context),
              ],
            ),
          ),
        ),
      ),
    );
  }
 
  String _formatTimestamp(DateTime timestamp) {
    final format = DateFormat('hh:mm a');
    return format.format(timestamp);
  }

void _showLocationWarningDialog(BuildContext context) {
  showDialog(
    context: context,
    builder: (BuildContext context) {
      return AlertDialog(
        title: Text(
          "Location Required",
          style: GoogleFonts.openSans(
            textStyle: TextStyle(
              fontWeight: FontWeight.bold,
              color: AppColors.primaryColor,
              letterSpacing: .5,
            ),
          ),
        ),
        content: Text(
          "Please press the 'Locate Me' button before chatting.",
          style: GoogleFonts.openSans(
            textStyle: TextStyle(
              color: AppColors.primaryColor,
              letterSpacing: .5,
            ),
          ),
        ),
        actions: [
          TextButton(
            onPressed: () {
              Navigator.of(context).pop();
            },
            child: Text(
              "OK",
              style: GoogleFonts.openSans(
                textStyle: TextStyle(
                  fontWeight: FontWeight.bold,
                  color: AppColors.primaryColor,
                  letterSpacing: .5,
                ),
              ),
            ),
          ),
        ],
      );
    },
  );
}

  Widget _buildMessageInput(BuildContext context) {
    final controller = Get.find<ChatController>();

    return Padding(
      padding: const EdgeInsets.all(8.0),
      child: Row(
        children: [
          Obx(() {
            if (controller.selectedGifUrl.value.isEmpty) {
              return Container();
            } else {
              return Stack(
                children: [
                  Image.network(
                    controller.selectedGifUrl.value,
                    height: 50,
                    width: 50,
                    fit: BoxFit.cover,
                  ),
                  IconButton(
                    icon: const Icon(
                      Icons.delete,
                      color: Colors.red,
                    ),
                    onPressed: () {
                      controller.selectedGifUrl.value = '';
                    },
                  ),
                ],
              );
            }
          }),
          IconButton(
            icon: const Icon(Icons.camera_alt, color: AppColors.primaryColor),
            onPressed: () {
              showUploadOption(
                context,
                () async {
                  Uint8List? imageCode =
                      await handleImageUpload(ImageSource.gallery);
                  if (imageCode != null) {
                    try {
                      String imageUrl = await StorageMethods()
                          .uploadImageToStorage(
                              'autogen/${controller.getstreetName}/$id/',
                              imageCode,
                              false);
                      controller.selectedGifUrl.value = imageUrl;
                      if (context.mounted) {
                        Navigator.of(context).pop();
                      }
                    } catch (e) {
                      print('error occurred: $e');
                    }
                  }
                },
                () async {
                  Uint8List? imageCode =
                      await handleImageUpload(ImageSource.camera);
                  if (imageCode != null) {
                    try {
                      String imageUrl = await StorageMethods()
                          .uploadImageToStorage(
                              'autogen/${controller.getstreetName}/$id/',
                              imageCode,
                              false);
                      controller.selectedGifUrl.value = imageUrl;
                      if (context.mounted) {
                        Navigator.of(context).pop();
                      }
                    } catch (e) {
                      print('error occurred: $e');
                    }
                  }
                },
                true,
              );
            },
          ),
          IconButton(
            icon: const Icon(Icons.gif, color: AppColors.primaryColor),
            onPressed: () {
              showModalBottomSheet(
                context: context,
                builder: (context) => Container(
                  height: MediaQuery.of(context).size.height * 0.5,
                  child: Column(
                    children: [
                      TextFormField(
                        textInputAction: TextInputAction.done,
                        onFieldSubmitted: (term) {
                          controller.searchByGifName();
                        },
                        controller: controller.searchGifText.value,
                        decoration: InputDecoration(
                          labelText: 'Search Gif...',
                          labelStyle: const TextStyle(color: AppColors.primaryColor),
                          suffixIcon: Obx(() {
                            return controller.isSeachActive.value
                                ? IconButton(
                                    icon: const Icon(Icons.close, color: AppColors.primaryColor),
                                    onPressed: controller.cancelSearch,
                                  )
                                : IconButton(
                                    icon: const Icon(Icons.search, color: AppColors.primaryColor),
                                    onPressed: controller.searchByGifName,
                                  );
                          }),
                          enabledBorder: OutlineInputBorder(
                            borderRadius: BorderRadius.circular(20),
                            borderSide: BorderSide.none,
                          ),
                          focusedBorder: OutlineInputBorder(
                            borderRadius: BorderRadius.circular(20),
                            borderSide: const BorderSide(color: AppColors.primaryColor),
                          ),
                          filled: true,
                          fillColor: Colors.white,
                        ),
                      ),
                      Expanded(
                        child: Obx(() => GridView.builder(
                          gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                            crossAxisCount: 3,
                            mainAxisSpacing: 8.0,
                            crossAxisSpacing: 8.0,
                          ),
                          padding: const EdgeInsets.all(8.0),
                          itemCount: controller.gifUrl.length,
                          itemBuilder: (context, index) {
                            return GestureDetector(
                              onTap: () {
                                controller.selectedGifUrl.value = controller.gifUrl[index];
                                Navigator.pop(context);
                              },
                              child: Image.network(controller.gifUrl[index]),
                            );
                          },
                        )),
                      ),
                    ],
                  ),
                ),
              );
            },
          ),
          IconButton(
            icon: const Icon(Icons.block, color: AppColors.primaryColor),
            onPressed: () {
              _showBlockDialog(context, controller.getstreetName!);
            },
          ),
         Flexible(
          child: TextField(
            controller: controller.messageTextCont,
            onSubmitted: sendMessage,
            decoration: InputDecoration.collapsed(
              hintText: 'Send a message',
            ),
            // Disable the input if the location is not set
            enabled: controller.isLocationSet.value,
          ),
        ),
        IconButton(
          icon: const Icon(
            Icons.send,
            color: AppColors.primaryColor,
          ),
          onPressed: () {
            if (controller.isLocationSet.value) {
              // Location is set, allow sending the message
              sendMessage('');
            } else {
              // Location not set, show a warning message
              _showLocationWarningDialog(context);
            }
          },
        ),
      ],
    ),
  );
}

  void _showBlockDialog(BuildContext context, String sender) {
    showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: Text(
            "Block User",
            style: GoogleFonts.openSans(
              textStyle: TextStyle(
                  fontWeight: FontWeight.bold,
                  color: AppColors.primaryColor,
                  letterSpacing: .5),
            ),
          ),
          content: Text(
            "Do you want to block messages from $sender?",
            style: GoogleFonts.openSans(
              textStyle:
                  TextStyle(color: AppColors.primaryColor, letterSpacing: .5),
            ),
          ),
          actions: [
            TextButton(
              onPressed: () {
                Navigator.of(context).pop();
              },
              child: Text(
                "Cancel",
                style: GoogleFonts.openSans(
                  textStyle: TextStyle(
                      fontWeight: FontWeight.bold,
                      color: AppColors.primaryColor,
                      letterSpacing: .5),
                ),
              ),
            ),
            TextButton(
              onPressed: () {
                // Call the method to block the user
                controller.blockUser(sender);
                Navigator.of(context).pop();
              },
              child: Text(
                "Block",
                style: GoogleFonts.openSans(
                  textStyle: TextStyle(
                      fontWeight: FontWeight.bold,
                      color: AppColors.primaryColor,
                      letterSpacing: .5),
                ),
              ),
            ),
          ],
        );
      },
    );
  }

  void sendMessage(String text) {
  final controller = Get.find<ChatController>();

  if (controller.isLocationSet.value) {
    final DateTime timestamp = DateTime.now();

    Map<String, dynamic> chatMessageMap = {
      "sender": controller.firebaseAuth.currentUser?.uid,
      "sendername": controller.firebaseAuth.currentUser?.email?.substring(0, 6),
      "time": timestamp,
    };
    chatMessageMap['message'] = controller.messageTextCont.text;

    if (controller.messageTextCont.text.toString().trim().isNotEmpty ||
        controller.selectedGifUrl.value.isNotEmpty) {
      controller.addAMessageToDB(
        messageVal: MessagePublicChat(
          senderId: controller.firebaseAuth.currentUser!.uid,
          message: controller.messageTextCont.text.toString().trim(),
          timestamp: timestamp,
          senderEmail: controller.firebaseAuth.currentUser!.email!,
          gifUrl: controller.selectedGifUrl.value,
          isGif: controller.selectedGifUrl.value.isNotEmpty,
        ),
      );
      controller.selectedGifUrl.value = '';
    }
  } else {
    // Location not set, show a warning message
    _showLocationWarningDialog(Get.context!);
  }
}

}