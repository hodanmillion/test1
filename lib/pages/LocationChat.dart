import 'dart:async';

import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:flutter_svprogresshud/flutter_svprogresshud.dart';
import 'package:geocoding/geocoding.dart' hide Location;
import 'package:geoflutterfire2/geoflutterfire2.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:location/location.dart';
import 'package:myapp/services/chat/public_chat_service.dart';
import 'package:http/http.dart' as http;

import '../components/message_tile.dart';
import 'dart:convert';

const String apiKey =
    'l1WfAFgqA5WupWoMaCaWKB12G54J6LtZ'; // Replace with your GIPHY API key
const String endpoint =
    'https://api.giphy.com/v1/gifs/trending?api_key=$apiKey&limit=10';

class LocationChatService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final geo = GeoFlutterFire();
  final FirebaseAuth _firebaseAuth = FirebaseAuth.instance;

  Future<void> upsertUserData(
      String userId, String name, double lat, double lng) async {
    GeoFirePoint userLocation = geo.point(latitude: lat, longitude: lng);
    return _firestore.collection('users').doc(userId).set({
      'name': name,
      'position': userLocation.data,
      // Add other fields as needed.
    });
  }

  Stream<List<DocumentSnapshot>> getUsersNearby(double lat, double lng) {
    GeoFirePoint center = geo.point(latitude: lat, longitude: lng);
    var radius = 20.0; // 20km radius
    var collectionReference = _firestore.collection('users');
    return geo.collection(collectionRef: collectionReference).within(
        center: center, radius: radius, field: 'position', strictMode: true);
  }
}

Future<List<String>> fetchGifs() async {
  final response = await http.get(Uri.parse(endpoint));
  List<String> urls = [];
  if (response.statusCode == 200) {
    final data = json.decode(response.body);
    return List<String>.from(
        data['data'].map((x) => x['images']['original']['url']));
  } else {
    throw Exception('Failed to load GIFs');
  }
}

class AutoGeneratedChat extends StatefulWidget {
  @override
  _AutoGeneratedChatState createState() => _AutoGeneratedChatState();
}

class _AutoGeneratedChatState extends State<AutoGeneratedChat> {
  final FirebaseAuth _firebaseAuth = FirebaseAuth.instance;
  String? selectedGifUrl;
  final LocationChatService _locationChatService = LocationChatService();
  Location location = Location();
  String streetname = "";
  LocationData? currentLocation;
  final PublicChatService _publicChatService = PublicChatService();
  Stream<QuerySnapshot>? chats;
  TextEditingController messageController = TextEditingController();
  String admin = "";

  @override
  void initState() {
    location.onLocationChanged.listen((LocationData updatedLocation) {
      if (mounted) {
        setState(() {
          currentLocation = updatedLocation;
        });
      }

      print("===display name" +
          _firebaseAuth.currentUser!.email!.substring(0, 6).toString());
    });
    location.getLocation().then((value) async {
      print("====getlocation====");
      List<Placemark> placemarks =
          await placemarkFromCoordinates(value.latitude!, value.longitude!);
      streetname = placemarks[0].street!;
      _publicChatService.createOrAddInGroup(
          value.latitude!, value.longitude!, location);
    });
    Future.delayed(const Duration(seconds: 15), () {
      print("====getchat====");

      getChatandAdmin();
    });
    Timer mytimer = Timer.periodic(const Duration(minutes: 15), (timer) {
      print("====Timer====");

      location.getLocation().then((value) {
        _publicChatService.createOrAddInGroup(
            value.longitude!, value.latitude!, location);
        setState(() {});
      });
    });

    super.initState();
  }

  Future<void> showGifSelectionModal() async {
    final List<String> gifUrls = await fetchGifs();

    showModalBottomSheet(
      context: context,
      builder: (BuildContext context) {
        return Container(
          height: 300, // Or any suitable height
          child: GridView.builder(
            gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
              crossAxisCount: 3, // Or any suitable count
            ),
            itemBuilder: (BuildContext context, int index) {
              return GestureDetector(
                onTap: () {
                  setState(() {
                    selectedGifUrl = gifUrls[index];
                  });
                  Navigator.pop(context);
                },
                child: Image.network(gifUrls[index], fit: BoxFit.cover),
              );
            },
            itemCount: gifUrls.length,
          ),
        );
      },
    );
  }

  getChatandAdmin() {
    _publicChatService.getChats(_publicChatService.groupId).then((val) {
      setState(() {
        chats = val;
        SVProgressHUD.dismiss();
      });
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        centerTitle: true,
        elevation: 1,
        title:
            Text("Chats - $streetname", style: TextStyle(color: Colors.white)),
        backgroundColor: Colors.deepPurple,
        actions: [
          IconButton(
            onPressed: () {},
            icon: const Icon(Icons.info, color: Colors.white),
          )
        ],
      ),
      body: Container(
        decoration: BoxDecoration(
          gradient: LinearGradient(
            colors: [
              Colors.deepPurple.shade100,
              Colors.white,
            ],
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
          ),
        ),
        child: Stack(
          children: <Widget>[
            chatMessages(),
            Positioned(
              bottom: 0,
              child: Container(
                width: MediaQuery.of(context).size.width,
                padding: EdgeInsets.symmetric(horizontal: 20, vertical: 10),
                decoration: BoxDecoration(
                  color: Colors.deepPurple.shade100,
                  boxShadow: [
                    BoxShadow(
                      color: Colors.grey.shade300,
                      offset: Offset(0.0, -1.0), //(x,y)
                      blurRadius: 5.0,
                    ),
                  ],
                ),
                child: Row(
                  children: [
                    selectedGifUrl == null
                        ? Container()
                        : Image.network(selectedGifUrl!,
                            height: 50, width: 50, fit: BoxFit.cover),
                    Expanded(
                      child: TextFormField(
                        controller: messageController,
                        style: TextStyle(color: Colors.deepPurple.shade700),
                        decoration: InputDecoration(
                          hintText: "Send a message...",
                          hintStyle: TextStyle(
                              color: Colors.deepPurple.shade300, fontSize: 14),
                          border: InputBorder.none,
                          filled: true,
                          fillColor: Colors.white,
                          contentPadding: EdgeInsets.all(10),
                          enabledBorder: OutlineInputBorder(
                            borderRadius: BorderRadius.circular(20),
                            borderSide: BorderSide.none,
                          ),
                          focusedBorder: OutlineInputBorder(
                            borderRadius: BorderRadius.circular(20),
                            borderSide: BorderSide(color: Colors.deepPurple),
                          ),
                        ),
                      ),
                    ),
                    GestureDetector(
                      onTap: () {
                        if (selectedGifUrl != null) {
                          sendMessage(gifUrl: selectedGifUrl);
                          setState(() {
                            selectedGifUrl =
                                null; // Clear the GIF after sending
                          });
                        } else {
                          sendMessage();
                        }
                      },
                      child: const CircleAvatar(
                        backgroundColor: Colors.deepPurple,
                        child: Icon(Icons.send, color: Colors.white),
                      ),
                    ),
                    SizedBox(width: 10),
                    GestureDetector(
                      onTap: () async {
                        // Fetch the list of GIFs
                        List<String> gifs = await fetchGifs();

                        print("==gif==" + gifs.length.toString());
                        showModalBottomSheet(
                          context: context,
                          builder: (context) => Container(
                            height: MediaQuery.of(context).size.height * 0.5,
                            // Set height to 50% of screen
                            child: ListView.builder(
                              itemCount: gifs.length,
                              itemBuilder: (context, index) => ListTile(
                                leading: Image.network(gifs[index], width: 50),
                                title: Text('GIF ${index + 1}'),
                                onTap: () {
                                  setState(() {
                                    selectedGifUrl = gifs[index];
                                  });
                                  Navigator.pop(
                                      context); // Close the modal sheet
                                },
                              ),
                            ),
                          ),
                        );
                      },
                      child: Icon(Icons.gif, color: Colors.white),
                    )
                  ],
                ),
              ),
            )
          ],
        ),
      ),
    );
  }

  chatMessages() {
    return StreamBuilder(
      stream: chats,
      builder: (context, AsyncSnapshot snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          const Center(
            child: CircularProgressIndicator(),
          );
        } else if (snapshot.hasError) {
          const Center(
            child: Text('Error fetching data...'),
          );
        }
        return ListView.builder(
          padding: const EdgeInsets.only(bottom: 60),
          itemCount: snapshot.data.docs.length,
          itemBuilder: (context, index) {
            return MessageTile(
              message: snapshot.data.docs[index]['message'],
              sender: snapshot.data.docs[index]['sendername'],
              sentByMe: _firebaseAuth.currentUser?.uid ==
                  snapshot.data.docs[index]['sender'],
              gifUrl: "",
              isGif: false,
            );
          },
        );
        //     : Container();
      },
    );
  }

  checkForChat() {
    chats!.length.then((value) {
      if (value > 0) {
        return chatMessages();
      } else {
        return const Text("No Chats");
      }
    });
  }

  void sendMessage({String? gifUrl}) {
    Map<String, dynamic> chatMessageMap = {
      "sender": _firebaseAuth.currentUser?.uid,
      "sendername": _firebaseAuth.currentUser?.email?.substring(0, 6),
      "time": DateTime.now().millisecondsSinceEpoch,
    };

    if (gifUrl != null) {
      chatMessageMap['gifUrl'] = gifUrl;
    } else if (messageController.text.isNotEmpty) {
      chatMessageMap['message'] = messageController.text;
      setState(() {
        messageController.clear();
      });
    } else {
      return; // Neither gif nor text message, so return without sending
    }

    _publicChatService.sendMessage(_publicChatService.groupId, chatMessageMap);
  }

  void selectGifToSend(String gifUrl) {
    Navigator.pop(context); // Close the GIF selection modal
    sendMessage(gifUrl: gifUrl);
  }
}
